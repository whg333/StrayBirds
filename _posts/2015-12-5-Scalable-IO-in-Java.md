---
layout: post
title: Scalable IO in Java——多Reactor的代码实现
description: "Scalable IO in Java——多Reactor的代码实现"
category: Java
tags: [github, jekyll]
comments: true
---

## Reactor模式和NIO
在Doug Lea大神的经典pdf文章《Scalable IO in Java》中，把Reactor模式和Java NIO整合起来，一步步理论结合Java代码构建了一套高可扩展/可伸缩的网络处理框架雏形，从当今的流行NIO框架（Netty、Main、Grizzly）中无不看到其本质均与该文章所述架构不谋而合（或者也可以说其实是借鉴并以现代化的方式实现了Doug Lea的思想吧），这里总结《Scalable IO in Java》中的要点并记录下自己实现多Reactor的过程中遇到的坑

### 网络服务的基本结构
当今网络上的各种基于TCP/IP的应用服务，其对1次请求的处理过程的本质流程结构均为

1. 从底层IO读取字节请求
2. 把读取后的字节请求进行解码成为自己的业务请求对象
3. 把解码后的业务请求对象进行业务处理
4. 把处理后的响应编码为底层IO可写入的字节响应
5. 利用底层IO返回（发出）编码后的字节响应

整体的流程如上述5步所示，但具体每步骤所使用到的一些技术手段不一样：例如解码协议是自定义的还是使用业界流行的？是文本协议还是二进制协议？处理过程就结合具体业务进行处理等

一般典型的网络服务设计如下图所示：
![classic_service_designs](http://cejdh.img46.wal8.com/img46/533449_20151202165458/144932454766.png)

可见其对每一个请求都新产生一个线程来进行处理，缺点就是线程的创建是消耗不小的系统资源的，且最关键的是如果并发访问突然激增到一定程度，那响应就会大打折扣，甚至由于系统资源不足导致系统崩溃。。。

这里给出自己的Java实现代码如下，比较简单，就是处理每个请求都new一个Thread

### 高可扩展/可伸缩系统的目标
基于“每请求每线程”的缺点比较明显且不可接受（严重时系统崩溃），Doug Lea大神提出了构建高可扩展/可伸缩系统的目标：

* 在激增请求的负载下至少优雅退化吧，即可以相应慢点，但别崩溃（无响应）呀
* 然后自动的增加处理所需资源（例如CPU、内存、磁盘、带宽）来渐进改善上一步中响应缓慢的问题

然后对于可用性和系统系能也提出了一些目标

* 低延时，其实还是高响应吧
* 能够满足最大峰值的处理请求
* 可调控的服务处理，例如处理耗时较多导致请求排队时，可多加如一些服务处理线程

最后总结了算法界的一个至理名言：
> 通常分而治之的方法是构建任何高可扩展/可伸缩系统目标的最佳解决方案！

（未完待续。。。）