---
layout: post
title: Scalable IO in Java——多Reactor的代码实现
description: "Scalable IO in Java——多Reactor的代码实现"
category: [Java]
tags: [reactor, nio]
comments: true
---

## Java高伸缩性IO处理
在Doug Lea大神的经典pdf文章《Scalable IO in Java》中，把Reactor模式和Java NIO整合起来，一步步理论结合Java代码构建了一套高伸缩性的网络处理框架雏形，从当今的流行NIO框架（Netty、Main、Grizzly）中无不看到其本质均与该文章所述架构不谋而合（或者也可以说其实是借鉴并以现代化的方式实现了Doug Lea的思想吧），这里总结《Scalable IO in Java》中的要点并记录下自己实现多Reactor的过程中遇到的坑

### 网络服务的基本结构
当今网络上的各种基于TCP/IP的应用服务，其对1次请求的处理过程的本质流程结构均为

1. 从底层IO读取字节请求
2. 把读取后的字节请求进行解码成为自己的业务请求对象
3. 把解码后的业务请求对象进行业务处理
4. 把处理后的响应编码为底层IO可写入的字节响应
5. 利用底层IO返回（发出）编码后的字节响应

![network_structure](http://cejdh.img47.wal8.com/img47/533449_20151202165458/14508614065.png)

整体的流程如上述5步所示，但具体每步骤所使用到的一些技术手段不一样：例如解码协议是自定义的还是使用业界流行的？是文本协议还是二进制协议？处理过程就结合具体业务进行处理等

一般典型的网络服务设计如下图所示：
![classic_service_designs](http://cejdh.img46.wal8.com/img46/533449_20151202165458/144932454766.png)

可见其对每一个请求都新产生一个线程来进行处理，缺点就是线程的创建是消耗不小的系统资源的，且最关键的是如果并发访问突然激增到一定程度，那响应就会大打折扣，甚至由于系统资源不足导致系统崩溃。。。

这里给出自己的Java实现代码如下，比较简单，就是处理每个请求都new一个Thread

### 高伸缩性系统的目标
基于“每请求每线程”的缺点比较明显且不可接受（严重时系统崩溃），Doug Lea大神提出了构建高伸缩性系统的目标：

* 在激增请求的负载下至少优雅退化吧，即可以相应慢点，但别崩溃（无响应）呀
* 然后自动的增加处理所需资源（例如CPU、内存、磁盘、带宽）来渐进改善上一步中响应缓慢的问题

然后对于系统整体的可用性和性能也提出了一些目标

* 低延时，其实就是尽量高响应
* 能够满足最大峰值的处理请求，即在访问量突增时不至于宕机
* 可调控的服务处理，例如请求较多时可多加入一些服务处理线程

最后总结了针对设计高伸缩性系统的一个至理名言：
> 分而治之通常都是构建任何高伸缩性系统的最佳解决方案！

### NIO框架的分而治之和事件驱动设计
针对NIO框架的分而治之是把处理过程拆分封装成小的任务——每个任务可以单独无阻塞的进行业务处理；每个任务在其可以立即执行处理的时候就立即执行，即把原来IO阻塞部分交由NIO框架去管理处理，真正的任务只无差别/幂等的处理真正的业务；NIO框架则把IO事件当做触发器去回调相关的任务去执行。

值得庆幸的在java.nio包中有对实现上述的NIO框架处理机制的支持：

1. **非阻塞（Non-blocking）**的读取和写入
2. **分发（dispatch）**IO事件到与其对应的任务并执行处理

这一切看起来都很类似Swing/AWT事件驱动设计：
![awt](http://cejdh.img47.wal8.com/img47/533449_20151202165458/145085344568.png)

而实际的Swing/AWT事件驱动本质上是多生产者/单一消费者模式，即有多个产生事件的地方（各种交互GUI），但是处理事件却只在一个地方（AWT/Event线程从事件队列获取事件一个个处理）。

## Reactor模式和NIO
同Swing/AWT事件驱动设计类似，Reactor模式也是多生产者/单一消费者模式，多个IO（读 /写）事件，但是处理IO事件却只在单一的EventLoop（事件循环）线程中分发给对应的任务处理器处理。基本的Reactor模式（单线程版）如下所示：
![reactor_b](http://cejdh.img47.wal8.com/img47/533449_20151202165458/145085907164.png)

下面来看下基于NIO的Reactor模式和Swing/AWT事件驱动设计的相似对比

| 类名称         | 作用                               | 对应Swing/AWT  |
| ------------- | --------------------------------- | --------------------------- |
| Reactor反应器  | EventLoop及时响应相对于的读/写IO事件 | AWT中的单例事件分发线程        |
|               | 分发到对应Handler处理器上进行业务处理 |                             |
| Handlers处理器 | 处理非阻塞读/写IO事件所对应的业务逻辑 | AWT中的ActionListeners处理器  |
| 事件绑定和处理  | 管理IO读/写事件到对应处理器的绑定     | AWT中的addActionListener绑定 |

然后再看下Java NIO中对实现Reactor提供了哪些支持

| 类名称         | 作用                                            |
| ------------- | ----------------------------------------------- |
| Channels      | 连接支持非阻塞IO的读/写的通道                      |
|               | 例如磁盘文件、网络Socket等都有对应的非阻塞IO的通道类  |
| Buffers       | Channels通道直接用来进行读/写操作的类数组对象        |
| Selectors     | 能知道哪些Channels通道集合存在IO事件               |
| SelectionKeys | 提供IO事件状态信息和IO事件绑定功能的类              |
|               | ![selKeys](http://cejdh.img47.wal8.com/img47/533449_20151202165458/145086171935.png)              |


### Reactor模式的多线程设计
单线程版Reactor模式是最基础的实现，其核心就是单线程Reactor的EventLoop在不断处理被Selector检测到的IO事件，但缺点也显而易见：

1. 随着客户端的连接数目的增加，如果业务的处理也需要消耗不小时间的话，那仅仅单次的EventLoop循环都会消耗不少时间才能进入下一次循环，导致IO事件阻塞在Selector里不能被及时轮询处理到
2. 而且随着多核CPU的爆发，当拥有多核机器时，应当适当利用多线程能力来分担本来是单线程的Rector，以去应对更多的客户端连接，否则依旧是单线程Rector的话，岂不是浪费了多核这个潮流强项了？

#### Worker Threads
针对第1条缺点引入了Worker Threads（工人线程，消费线程，即有一群工人老早就做好准备处理即将到来任务了）——线程池；理由是Reactor的EventLoop轮询应当快速响应IO触发事件，而不应当消耗在本应该是任务处理器处理的业务上：
![reactor_m1](http://cejdh.img47.wal8.com/img47/533449_20151202165458/145085907171.png)

#### Multiple Reactor Threads
针对第2条Multiple Reactor Threads，即多个Reactor线程；理由是随着客户端连接越来越多，单个Reactor线程处理IO能力会达到饱和状态，在多核机器上看到的现象是只有一个核心利用率较高，其他核心是闲置的，所以应当适当利用多核优势，扩展成匹配CPU核数的多个Reactor，达到分担IO负载的目的：
![reactor_m2](http://cejdh.img47.wal8.com/img47/533449_20151202165458/145085907177.png)


## 代码实现

（未完待续。。。）